1. Exception logging pattern

In the logjira paper, we find that developers are confused about exception logging in many cases. They are confused about
the whether to log, the log level, and whether to log the stack trace.

We can leverage the logging-plugin to find the logging patterns for each methodCall-exception pairs.
For example, if a openFile method call triggers an IOException, then we can look at the logging patterns for
the openFile -> IOException scenarios. Hopefully, they should be logged similarly.

We can add other metrics, such as the number of containing loops, the number of method calls in the try block,
and whether the exception is handled.

Metrics:

Method call that throws exception // what happened? what causes an error? (need to consider exception class hierarchies)
                                  // use qualified method name: className.methodName
Number of method call that throws the caught exception // how clear is the exception caught related to the method throwing the exception
Is method from java-lang / third-party library / project?
Exception type // how serious the problem is (need to consider exception class hierarchies)
                                             // maybe need to use qualified exceptions,
                                             // there are some conflicts, e.g., BinaryProtocol.ProtocolException versus the Java language one.
Is exception type from java-lang / third-party library / project?
Is check exception / runtime exception / error?
Number of caught exceptions
Is caught exception a super class of the thrown exception?
Is contained in loop (two metrics) // how the logging would be replicated
  > is logging statement inside a loop in catch block?
  > is catch block inside a loop?
Exception handling method
Number of method calls before/after the logging statement // how much effort is used to handle the exception
Lines of code before/after the logging statement // how much effort is used to handle the exception
Number of method calls before/after the method call throwing the exception // how close the catch block is related to the method call
Number of blocks containing the logging statement but within the catch block (excluding logging guards) // how close this logging statement is related to the exception
If the exception is re-thrown // re-thrown means the method pass the exception to its caller to handle
Number of throw statements in the catch block
Does the catch block have returns? // return might indicate an problem hard to handle
Does the try block have returns? // return might indicate an important task failed to finish (e.g., fail to return)


Challenges:
RuntimeException might not be declares in method throws clauses.

Notes:

Basic exception type:
Checked exception (subclasses of Exception which is a subclass of throwable)
RuntimeException (subclasses of RuntimeException which is a subclass of Exception)
Error (subclasses of Error which is a subclass of throwable)

Checked exceptions are subject to the Catch or Specify Requirement.
All exceptions are checked exceptions, except for those indicated by Error, RuntimeException, and their subclasses.
RuntimeException and Error are not subject to the Catch or Specify Requirement.

For RuntimeException and Error exception, we could not determine the throwing methods using exception matching.
In this case, if there is only one method in the try block, use that method; otherwise, use "Unknown".

If there are multiple exceptions or matched method calls, we use Multi_* labels.
(e.g., Multi_Library, Multi_Lang, Multi_Project, Multi_Library_Project, ...)

Use log/level/tracktrace ratio to represent a type of exception or method call, instead of using the exception types or method calls.





